<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Multiplayer Snake</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <script>
      const socket = io();
      const canvas = document.createElement("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      document.body.appendChild(canvas);
      const ctx = canvas.getContext("2d");


      const worldSize = 100;
      const cellSize = Math.max(canvas.width, canvas.height) / 100;
      const viewWidth = Math.floor(canvas.width / cellSize);
      const viewHeight = Math.floor(canvas.height / cellSize);
     


      let localPlayerId = null;
      let gameState = { players: {}, food: [], debris: [] };

      let camera = { x: 0, y: 0 };
      let direction = 0;

      function wrapPosition(pos, size) {
        return (pos + size) % size;
      }

      function wrappedDistance(a, b, size) {
        let dist = a - b;
        if (dist > size / 2) dist -= size;
        if (dist < -size / 2) dist += size;
        return dist;
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function drawWrapped(obj, color) {
        ctx.fillStyle = color;
        const dx = wrappedDistance(obj.x, camera.x + viewWidth / 2, worldSize);
        const dy = wrappedDistance(obj.y, camera.y + viewHeight / 2, worldSize);
        const x = (viewWidth / 2 + dx) * cellSize;
        const y = (viewHeight / 2 + dy) * cellSize;
        ctx.fillRect(x, y, cellSize, cellSize);
      }

      function drawMinimap(player) {
        const mapSize = 100;
        const scale = mapSize / worldSize;
        const padding = 10;
        const xOffset = canvas.width - mapSize - padding;
        const yOffset = canvas.height - mapSize - padding;
        const centerX = xOffset + mapSize / 2;
        const centerY = yOffset + mapSize / 2;

        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(xOffset, yOffset, mapSize, mapSize);

        function drawDot(x, y, size, color) {
          const dx = wrappedDistance(x, camera.x + viewWidth / 2, worldSize);
          const dy = wrappedDistance(y, camera.y + viewHeight / 2, worldSize);
          const px = centerX + dx * scale;
          const py = centerY + dy * scale;

          ctx.fillStyle = color;
          ctx.fillRect(px, py, size, size);
        }

        for (let id in gameState.players) {
          for (let s of gameState.players[id].snake) {
            drawDot(s.x, s.y, 2, id === localPlayerId ? "white" : "gray");
          }
        }
      }

      document.addEventListener("keydown", function (e) {
        let newDir = 0;
        if ((e.code === "ArrowUp" || e.code === "KeyW") && direction != 4) {
          newDir = 3;
        }
        if ((e.code === "ArrowDown" || e.code === "KeyS") && direction != 3) {
          newDir = 4;
        }
        if ((e.code === "ArrowLeft" || e.code === "KeyA") && direction != 2) {
          newDir = 1;
        }
        if ((e.code === "ArrowRight" || e.code === "KeyD") && direction != 1) {
          newDir = 2;
        }
        if (newDir !== 0) {
          direction = newDir;
          socket.emit("direction", newDir);
        }
      });

      socket.on("connect", () => {
        localPlayerId = socket.id;
      });

      socket.on("state", (state) => {
        gameState = state;
        const player = gameState.players[localPlayerId];
        if (player && camera.x === 0 && camera.y === 0) {
          // Center camera exactly on player's starting position
          camera.x = wrapPosition(
            player.position.x - Math.floor(viewWidth / 2),
            worldSize
          );
          camera.y = wrapPosition(
            player.position.y - Math.floor(viewHeight / 2),
            worldSize
          );
        }
      });

      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const player = gameState.players[localPlayerId];
        if (!player) return requestAnimationFrame(gameLoop);

        // Smooth camera movement
        const camCenterX = camera.x + viewWidth / 2;
        const camCenterY = camera.y + viewHeight / 2;
        let dx = wrappedDistance(player.position.x, camCenterX, worldSize);
        let dy = wrappedDistance(player.position.y, camCenterY, worldSize);
        const followStrength = 0.005;
        const softEdge = Math.min(viewWidth, viewHeight) * 0.15;

        if (Math.abs(dx) > softEdge) {
          camera.x = wrapPosition(
            lerp(
              camera.x,
              camera.x + dx - Math.sign(dx) * softEdge,
              followStrength
            ),
            worldSize
          );
        }
        if (Math.abs(dy) > softEdge) {
          camera.y = wrapPosition(
            lerp(
              camera.y,
              camera.y + dy - Math.sign(dy) * softEdge,
              followStrength
            ),
            worldSize
          );
        }

        // Draw everything
        for (let id in gameState.players) {
          const p = gameState.players[id];
          for (let s of p.snake)
            drawWrapped(s, id === localPlayerId ? "blue" : "gray");
        }

        for (let f of gameState.food) drawWrapped(f, "green");
        for (let d of gameState.debris) drawWrapped(d, "red");

        ctx.fillStyle = "black";
        ctx.font = "20px Arial";
        ctx.fillText("Score: " + player.score, 10, 20);

        drawMinimap(player);

        requestAnimationFrame(gameLoop);
      }

      gameLoop();
    </script>
  </body>
</html>
